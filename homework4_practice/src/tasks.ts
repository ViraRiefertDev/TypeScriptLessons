// =============== ФУНкЦІЇ ==================

//=========================================================================================
// 1. Функція formatName повертає ім’я у форматі "First Last", або просто "First".

//=========================================================================================
// 2. Функція повертає середнє арифметичне з будь-якої кількості чисел.

//=========================================================================================
// 2.1. Функція виводить на екран тільки ті рядки, довжина яких є більшою за 5. 
// Кількість параметрів-рядків може бути довільною.

//=========================================================================================
// 2.2. Функція повертає кількість входжень символу у рядку.

//=========================================================================================
// 2.2. Функція приймає довільну кількість рядків і повертає один рядок, розділений комами.

//=========================================================================================
// 2.3. Функція приймає масив ідентифікаторів (чисел або рядків). Пірадувати кількість ідентифікаторів чисел.

//=========================================================================================
// 3. Напиши функцію, яка повертає тільки ті числа, для яких predicate (функція-предикат, яка визначає умову) повертає true

//=========================================================================================
// 4. Напиши узагальнену функцію, яка повертає перший елемент параметра-масиву незалежно від типу.

//=========================================================================================
// 5. Оголоси об’єкт counter із властивістю count: number та методом increment, який збільшує count на 1 
// (викоритати this у параматрах).

//=========================================================================================
// 5.1. Таймер. Властивість seconds  і метод tick (викорстати параметр this)

//=========================================================================================
// 6. Функція-композитор. Напиши функцію яка приймає кілька функцій і повертає нову, 
// що виконує їх послідовно зліва направо (і результат попередньої і вхідним параметром для наступної).

//=========================================================================================
// 7. Логгер з рівнем важливості. Функція приймає повідомлення і рівень важливості ("info", "warn" , "error").

// =============== ПЕРЕВАНТАЖЕННЯ ===========
// 1. Калькулятор. Створи функцію calculate, яка:
// •	при виклику calculate(2, 3, "+") повертає 5
// •	при виклику calculate(2, 3, "*") повертає 6
// •	при виклику calculate(2, ‘OK’, "*") повертає ‘OKOK’
// •	при виклику calculate("2", "3", "+") повертає "23"



// 2. Форматування дати Функція formatDate:
// •	приймає Date і повертає рядок формату YYYY-MM-DD;
// •	або приймає string і повертає Date.


// 3. Перевантаження для логування. Функція log:
// •	якщо передано string → просто друкує,
// •	якщо string[] → друкує кожен рядок окремо.
// // Перевірка (в консолі)


// 4. Пошук користувача. Функція findUser:
// •	якщо передано id: number → повертає користувача з масиву за id;
// •	якщо name: string → шукає користувача за іменем.


// 5. Перетворення у верхній/нижній регістр. Функція changeCase:
// •	якщо передано один рядок → повертає toUpperCase(),
// •	якщо два рядки й 'lower' → об’єднує і знижує регістр.

// 6. Гнучка функція reverse. Функція reverse:


// 7. Злиття або порівняння. Функція processInput приймає або два масиви — зливає їх, або два числа — повертає різницю.


// ========================== union ==================================
// 1.	Форматування повідомлення. Функція formatMessage приймає або рядок, або число(повертає рядок з символом «#»), і повертає рядок (у верхньому регістрі).



// 2.	Визначення площі фігури. Створи типи для Circle і Rectangle та функцію getArea(shape), що обчислює площу залежно від типу фігури.

// 3.	Обробка помилки або успішного результату. Тип Result може бути або Success, або Error. Напиши функцію, яка друкує результат.

// 4.	Прийом різних форматів часу. Функція toDate приймає або Date, або рядок, і повертає Date.


// =============== enum ==================
// 1.	Визначення днів тижня. Перевірити чи вихідний.
// enum WeekDay {
//   Sun,
//   Mon,
//   Tue,
//   Wen,
//   Thu,
//   Fri,
//   Sat,
// }


// 2.	Є чіткий набір можливих варіантів (up/down/left/right) і важливо уникнути орфографічних помилок. Зробити функцію, яка б воводила напрямок у верхньому регістрі.
// enum Direction {
//   Up = 'up',
//   Down = 'down',
//   Left = 'left',
//   Right = 'right',
// }


// 3.	Рівні логування. Треба задати стабільні рівні логів (тип логів: Info,  Warn,  Error). Ррозробити функції для логування з використанням відповідних методів.


// 4.	Статуси замовлення. Є бізнес-логіка з фіксованими станами ("pending", "shipped", "delivered", "cancelled"). Дано масив об'єктів з відповідними статустами. Створити функцію, яка б повертала відфільтрований список за значенням статусу.

// 5.	Типи користувачів у системі.  Є фіксований набір ролей із різними правами доступу (Admin, Editor,  Viewer). Визначити кількість адмінів.


// 6.	Типи користувачів у системі.  Є фіксований набір ролей із різними правами доступу  (Admin, Editor,  Viewer). Вони описані у порядку спадання важливості.  На основі заданого статусу треба визначити чи є він найвищим.



// 7.	Типи оплати. Потрібно обробляти кілька типів оплати ("cash", "card",  "applePay") у функціях чи API. Визначити сумарно скільки було зроблено оплат кожним з видів
// 8.	Режими гри. Є фіксовані режими або складності гри (Easy,  Normal,  Hard). Розробити функцію, для визначення кількості суперників у залежності від складності (2, 5, 30).
// 9.	Статуси мережі.
// 10.	Є набір стабільних станів користувачів ("online", "offline","connecting"). Якщо користувач "offline", то повідмляти його про це.

// =============== ПЕРЕВІРКА ТИПІВ ==================
// 1.	Напиши функцію assertIsNameString, яка перевіряє, що параметр є рядком і починається з великої літери



// 2.	Перевірка на число.


// 3.	Перевірка на об'єкт дати.


// 4.	Перевірка на масив чисел

// 5.	Перевірка на масив рядків
// 6.	Перевірка на об’єкт (не null)
// 7.	Перевірка на певний тип об’єкта
// type User = { name: string; age: number }

// 8.	Перевірка типу через об’єднання (union)

// 9.	У локальному сховищі (localStorage) збережено масив об’єктів різних типів : користувачів (User) та замовлень (Order). Зчитати дані з localStorage. Визначити, які елементи належать до типу User, а які — до Order. Розділити їх у два окремі масиви.
